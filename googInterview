
Please use this Google doc to code during your interview. To make hands free coding a little easier, we recommend that you use a headset or a phone with speaker option.

Best,
Google Staffing

There is a list of 995 unique unsorted numbers between 0 and 1000, i.e. 5 numbers are missing. Write a function that returns those 5 numbers. 
[Assume we have an unsorted list of all numbers between 0 and including 999. 5 of those numbers are randomly removed, which leaves us 995 numbers. The code gets this list and should return a list of those 5 numbers]


Given a list of 995 unique numbers between [0,999] find the five numbers that are missing.

The input list has no order.

[1,2,3,4,6,7,9]
range(10) = [0,1,2,3,4,5,6,7,8,9]

index in sorted_array = 5
index in range = 7

output_list = [0,5]



def find_missing(array):
	sorted_array = sorted(array)
	output_list = []
	count = 0
	for i in range(1000):
		if i != sorted_array[i-count]:
			output_list.append(i)
			count += 1
	return output_list

Time Complexity : O(n lg n) (assuming merge sort or quicksort)

------------------------------------------------

def find_missing(array):
	boolean_array = [0] * 1000 #makes an array of length 1000
	for i in array:
		boolean_array[i] = 1
	output_list = []
	for j in range(len(boolean_array)):
		if boolean_array[j]  == 0:
			output_list.append(j)
	return output_list

O(n)

0 - 999
objects = [Object()] * 1000

-------------------------------------------------------------------------------------



Define a class and a function to test equivalency of a domino tile and a box containing 5 domino tiles.

A)
Write a class definition for managing a list of domino tiles. (If you are not familiar with a domino, assume a coin that has a number on each side). Each domino has two numbers on them, each number is between 0 and 6. We only want to compare the dominos, as are they equal or not.


Each domino has two numbers.

class Domino:
	def __init__(self, side1, side2)
		self.side1 = side1
		self.side2 = side2
		self.my_set = set([side1,side2])
def __eq__(self, other):
		return self.my_set == other.my_set
		


B)
Now assume we have a new entity box which contains 5 tiles each. Write a class for Box. Again we only care about the boxes being the same or not.

class Domino_Box:
	def __init__(self, domino_list):
		if len(domino_list) !=5:
			print “cannont instantiate domino box with anything other than five tiles”
		else:
			self.domino_list = domino_list

	def __eq__(self,other_box):
		list2 = other_box.domino_list
		for dom in self.domino_list:
			if dom in other_box.list2:
				ind = list2.index(dom)
				list2.pop(ind)
			else:
				return False
		return True
		

Box1: [[1,1],[1,1]]
Box2: [[1,2] ,[1,1]]


right now if Box1 == Box2: return True

Time Complexity of __eq__method
	We loop through self.domino_list→ Loop body happens 5 times = n times
	if dom in other_box.list2  -> this takes O(n)
	else: O(1)

	The overall complexity is O(n (n +1) +1) = O (n^2)
-------------------------------------------


